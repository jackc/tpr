package data
// This file is automatically generated by pgxdata.

import (
	"fmt"
	"hash/fnv"
	"io"
	"context"

	errors "golang.org/x/xerrors"
	"github.com/jackc/pgx/v4"
	"github.com/jackc/pgconn"
)

const PGXDATA_VERSION = "0.1.0"

var ErrNotFound = errors.New("not found")

type Queryer interface {
	Query(ctx context.Context, sql string, args ...interface{}) (pgx.Rows, error)
	QueryRow(ctx context.Context, sql string, args ...interface{}) pgx.Row
	Exec(ctx context.Context, sql string, arguments ...interface{}) (pgconn.CommandTag, error)
}

type preparer interface {
	Prepare(ctx context.Context, name, sql string) (*pgx.PreparedStatement, error)
	Deallocate(ctx context.Context, name string) error
}

func prepareQuery(ctx context.Context, db Queryer, name, sql string, args ...interface{}) (pgx.Rows, error) {
	if preparer, ok := db.(preparer); ok {
		if _, err := preparer.Prepare(ctx, name, sql); err != nil {
			return nil, err
		}
		sql = name
	}

	return db.Query(ctx, sql, args...)
}

func prepareQueryRow(ctx context.Context, db Queryer, name, sql string, args ...interface{}) pgx.Row {
	if preparer, ok := db.(preparer); ok {
		// QueryRow doesn't return an error, the error is encoded in the pgx.Row.
		// Since that is private, Ignore the error from Prepare and run the query
		// without the prepared statement. It should fail with the same error.
		if _, err := preparer.Prepare(ctx, name, sql); err == nil {
			sql = name
		}
	}
	return db.QueryRow(ctx, sql, args...)
}

func prepareExec(ctx context.Context, db Queryer, name, sql string, args ...interface{}) (pgconn.CommandTag, error) {
	if preparer, ok := db.(preparer); ok {
		if _, err := preparer.Prepare(ctx, name, sql); err != nil {
			return nil, err
		}
		sql = name
	}

	return db.Exec(ctx, sql, args...)
}

func preparedName(baseName, sql string) string {
	h := fnv.New32a()
	if _, err := io.WriteString(h, sql); err != nil {
		// hash.Hash.Write never returns an error so this can't happen
	  panic("failed writing to hash")
	}

	return fmt.Sprintf("%s%d", baseName, h.Sum32())
}
