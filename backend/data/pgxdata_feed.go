package data

// This file is automatically generated by pgxdata.

import (
	"strings"

	"github.com/jackc/pgx"
	"github.com/jackc/pgx/pgtype"
)

type Feed struct {
	ID              pgtype.Int4
	Name            pgtype.Varchar
	URL             pgtype.Varchar
	LastFetchTime   pgtype.Timestamptz
	ETag            pgtype.Varchar
	LastFailure     pgtype.Varchar
	LastFailureTime pgtype.Timestamptz
	FailureCount    pgtype.Int4
	CreationTime    pgtype.Timestamptz
}

const countFeedSQL = `select count(*) from "feeds"`

func CountFeed(db Queryer) (int64, error) {
	var n int64
	err := prepareQueryRow(db, "pgxdataCountFeed", countFeedSQL).Scan(&n)
	return n, err
}

const SelectAllFeedSQL = `select
  "id",
  "name",
  "url",
  "last_fetch_time",
  "etag",
  "last_failure",
  "last_failure_time",
  "failure_count",
  "creation_time"
from "feeds"`

func SelectAllFeed(db Queryer) ([]Feed, error) {
	var rows []Feed

	dbRows, err := prepareQuery(db, "pgxdataSelectAllFeed", SelectAllFeedSQL)
	if err != nil {
		return nil, err
	}

	for dbRows.Next() {
		var row Feed
		dbRows.Scan(
			&row.ID,
			&row.Name,
			&row.URL,
			&row.LastFetchTime,
			&row.ETag,
			&row.LastFailure,
			&row.LastFailureTime,
			&row.FailureCount,
			&row.CreationTime,
		)
		rows = append(rows, row)
	}

	if dbRows.Err() != nil {
		return nil, dbRows.Err()
	}

	return rows, nil
}

const selectFeedByPKSQL = `select
  "id",
  "name",
  "url",
  "last_fetch_time",
  "etag",
  "last_failure",
  "last_failure_time",
  "failure_count",
  "creation_time"
from "feeds"
where "id"=$1`

func SelectFeedByPK(
	db Queryer,
	id int32,
) (*Feed, error) {
	var row Feed
	err := prepareQueryRow(db, "pgxdataSelectFeedByPK", selectFeedByPKSQL, id).Scan(
		&row.ID,
		&row.Name,
		&row.URL,
		&row.LastFetchTime,
		&row.ETag,
		&row.LastFailure,
		&row.LastFailureTime,
		&row.FailureCount,
		&row.CreationTime,
	)
	if err == pgx.ErrNoRows {
		return nil, ErrNotFound
	} else if err != nil {
		return nil, err
	}

	return &row, nil
}

func InsertFeed(db Queryer, row *Feed) error {
	args := pgx.QueryArgs(make([]interface{}, 0, 9))

	var columns, values []string

	if row.ID.Status != pgtype.Undefined {
		columns = append(columns, `id`)
		values = append(values, args.Append(&row.ID))
	}
	if row.Name.Status != pgtype.Undefined {
		columns = append(columns, `name`)
		values = append(values, args.Append(&row.Name))
	}
	if row.URL.Status != pgtype.Undefined {
		columns = append(columns, `url`)
		values = append(values, args.Append(&row.URL))
	}
	if row.LastFetchTime.Status != pgtype.Undefined {
		columns = append(columns, `last_fetch_time`)
		values = append(values, args.Append(&row.LastFetchTime))
	}
	if row.ETag.Status != pgtype.Undefined {
		columns = append(columns, `etag`)
		values = append(values, args.Append(&row.ETag))
	}
	if row.LastFailure.Status != pgtype.Undefined {
		columns = append(columns, `last_failure`)
		values = append(values, args.Append(&row.LastFailure))
	}
	if row.LastFailureTime.Status != pgtype.Undefined {
		columns = append(columns, `last_failure_time`)
		values = append(values, args.Append(&row.LastFailureTime))
	}
	if row.FailureCount.Status != pgtype.Undefined {
		columns = append(columns, `failure_count`)
		values = append(values, args.Append(&row.FailureCount))
	}
	if row.CreationTime.Status != pgtype.Undefined {
		columns = append(columns, `creation_time`)
		values = append(values, args.Append(&row.CreationTime))
	}

	sql := `insert into "feeds"(` + strings.Join(columns, ", ") + `)
values(` + strings.Join(values, ",") + `)
returning "id"
  `

	psName := preparedName("pgxdataInsertFeed", sql)

	return prepareQueryRow(db, psName, sql, args...).Scan(&row.ID)
}

func UpdateFeed(db Queryer,
	id int32,
	row *Feed,
) error {
	sets := make([]string, 0, 9)
	args := pgx.QueryArgs(make([]interface{}, 0, 9))

	if row.ID.Status != pgtype.Undefined {
		sets = append(sets, `id`+"="+args.Append(&row.ID))
	}
	if row.Name.Status != pgtype.Undefined {
		sets = append(sets, `name`+"="+args.Append(&row.Name))
	}
	if row.URL.Status != pgtype.Undefined {
		sets = append(sets, `url`+"="+args.Append(&row.URL))
	}
	if row.LastFetchTime.Status != pgtype.Undefined {
		sets = append(sets, `last_fetch_time`+"="+args.Append(&row.LastFetchTime))
	}
	if row.ETag.Status != pgtype.Undefined {
		sets = append(sets, `etag`+"="+args.Append(&row.ETag))
	}
	if row.LastFailure.Status != pgtype.Undefined {
		sets = append(sets, `last_failure`+"="+args.Append(&row.LastFailure))
	}
	if row.LastFailureTime.Status != pgtype.Undefined {
		sets = append(sets, `last_failure_time`+"="+args.Append(&row.LastFailureTime))
	}
	if row.FailureCount.Status != pgtype.Undefined {
		sets = append(sets, `failure_count`+"="+args.Append(&row.FailureCount))
	}
	if row.CreationTime.Status != pgtype.Undefined {
		sets = append(sets, `creation_time`+"="+args.Append(&row.CreationTime))
	}

	if len(sets) == 0 {
		return nil
	}

	sql := `update "feeds" set ` + strings.Join(sets, ", ") + ` where ` + `"id"=` + args.Append(id)

	psName := preparedName("pgxdataUpdateFeed", sql)

	commandTag, err := prepareExec(db, psName, sql, args...)
	if err != nil {
		return err
	}
	if commandTag.RowsAffected() != 1 {
		return ErrNotFound
	}
	return nil
}

func DeleteFeed(db Queryer,
	id int32,
) error {
	args := pgx.QueryArgs(make([]interface{}, 0, 1))

	sql := `delete from "feeds" where ` + `"id"=` + args.Append(id)

	commandTag, err := prepareExec(db, "pgxdataDeleteFeed", sql, args...)
	if err != nil {
		return err
	}
	if commandTag.RowsAffected() != 1 {
		return ErrNotFound
	}
	return nil
}
